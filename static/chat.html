<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM Q&A with Streaming</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .typing-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            background-color: #666;
            border-radius: 50%;
            margin: 0 2px;
            animation: typing 1.4s infinite ease-in-out both;
        }
        .typing-indicator:nth-child(1) { animation-delay: -0.32s; }
        .typing-indicator:nth-child(2) { animation-delay: -0.16s; }
        @keyframes typing {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">
    <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-2xl">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">LLM Q&A Interface (Streaming)</h1>
        <p class="text-center text-gray-600 mb-8">
            Real-time streaming responses from the LLM.
        </p>
        <form id="qa-form" class="space-y-4">
            <textarea
                id="message-input"
                class="w-full p-4 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all duration-200 resize-none"
                rows="4"
                placeholder="Ask me something... (e.g., 'What is the price Air Fryer?')"
                required
            ></textarea>
            <button
                type="submit"
                id="submit-button"
                class="w-full bg-blue-600 text-white font-semibold py-3 px-4 rounded-lg hover:bg-blue-700 transition-colors duration-200 disabled:bg-gray-400 disabled:cursor-not-allowed"
            >
                Send to Orchestrator
            </button>
        </form>
        <div id="response-container" class="mt-8">
            <h2 class="text-xl font-semibold text-gray-800 mb-4">Response:</h2>
            <div id="response-box" class="bg-gray-50 p-6 rounded-lg border border-gray-200 min-h-32">
                <p id="response-text" class="text-gray-700">No response yet. Send a message to get started!</p>
                <div id="typing-indicator" class="hidden flex space-x-1 mt-2">
                    <div class="typing-indicator"></div>
                    <div class="typing-indicator"></div>
                    <div class="typing-indicator"></div>
                </div>
            </div>
            <button
                id="reconnect-button"
                class="hidden mt-4 w-full bg-yellow-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-yellow-600 transition-colors duration-200"
            >
                Start New Session
            </button>
        </div>
    </div>
    <script>
        const form = document.getElementById('qa-form');
        const messageInput = document.getElementById('message-input');
        const responseText = document.getElementById('response-text');
        const responseBox = document.getElementById('response-box');
        const submitButton = document.getElementById('submit-button');
        const typingIndicator = document.getElementById('typing-indicator');
        const reconnectButton = document.getElementById('reconnect-button');
        let ws = null;
        let sessionInitialized = false;
        let sessionId = null;
        let isStreaming = false;
        let currentResponse = '';

        // Try different WebSocket URLs if the primary fails
        const getWebSocketUrls = (userId, sessionId) => {
            //const baseUrls = [
                //`wss://${window.location.host}/messenger/ws/${userId}/${sessionId}`,
                //`wss://${window.location.hostname}:40331/messenger/ws/${userId}/${sessionId}`,
                //`wss://${window.location.hostname}:6000/messenger/ws/${userId}/${sessionId}`
            //];
            //return baseUrls;
        // Dynamically determine the protocol (ws for http, wss for https)
        const ws_scheme = window.location.protocol === "https:" ? "wss" : "ws";
        
        // Use the current host (e.g., 'localhost:8000' or 'ols.vexu.ai')
        const host = window.location.host;
        
        // Primary URL: Use the same scheme and host as the current page
        const primaryUrl = `${ws_scheme}://${host}/messenger/ws/${userId}/${sessionId}`;
        
        // Fallback URLs (if needed for specific local setups)
        const fallbackUrls = [
            `${ws_scheme}://localhost:40331/messenger/ws/${userId}/${sessionId}`,
            `${ws_scheme}://localhost:6000/messenger/ws/${userId}/${sessionId}`
        ];
        
        return [primaryUrl, ...fallbackUrls];
        
        
        
        };

        function showTypingIndicator() {
            typingIndicator.classList.remove('hidden');
            responseText.textContent = '';
        }

        function hideTypingIndicator() {
            typingIndicator.classList.add('hidden');
        }

        function appendToResponse(text) {
            currentResponse += text;
            responseText.textContent = currentResponse;
            responseBox.scrollTop = responseBox.scrollHeight;
        }

        function resetResponse() {
            currentResponse = '';
            responseText.textContent = '';
        }

        async function initializeSession() {
            console.log('Starting session initialization...');
            try {
                responseText.textContent = 'Initializing session...';
                
                // Try multiple endpoints for session initialization
                const endpoints = [`${window.location.origin}/messenger/chat/init`,'http://localhost:40331/messenger/chat/init'];
                // const endpoints = ['/messenger/chat/init','http://localhost:40331/messenger/chat/init'];
                
                let initResponse = null;
                let lastError = null;

                for (const endpoint of endpoints) {
                    try {
                        console.log(`Trying endpoint: ${endpoint}`);
                        const response = await fetch(endpoint, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                owner_id: '+12345952496',
                                agent_id: 'AGENT_ID',
                                user_id: 'USER_ID'
                            })
                        });
                        if (response.ok) {
                            initResponse = await response.json();
                            break;
                        }
                    } catch (error) {
                        lastError = error;
                        console.log(`Endpoint ${endpoint} failed:`, error);
                    }
                }

                if (!initResponse) {
                    throw new Error(lastError?.message || 'All initialization endpoints failed');
                }

                if (initResponse.status === 'success') {
                    sessionInitialized = true;
                    sessionId = initResponse.session_id;
                    connectWebSocket(sessionId);
                } else {
                    throw new Error(initResponse.message || 'Failed to initialize session');
                }
            } catch (error) {
                console.error('Failed to initialize session:', error);
                responseText.textContent = `Error: ${error.message}`;
                submitButton.disabled = true;
                if (confirm('Server connection failed. Would you like to use demo mode?')) {
                    enableDemoMode();
                }
            }
        }

        function connectWebSocket(sessionId) {
            if (!sessionId) {
                responseText.textContent = 'Error: No session ID available';
                return;
            }

            const wsUrls = getWebSocketUrls(sessionId);
            let currentUrlIndex = 0;

            const tryNextWebSocket = () => {
                if (currentUrlIndex >= wsUrls.length) {
                    responseText.textContent = 'Error: Could not connect to any WebSocket server';
                    submitButton.disabled = true;
                    return;
                }

                const wsUrl = wsUrls[currentUrlIndex];
                console.log('Attempting WebSocket connection to:', wsUrl);

                ws = new WebSocket(wsUrl);

                ws.onopen = () => {
                    console.log('WebSocket connection established.');
                    responseText.textContent = 'Connected! You can now send messages.';
                    submitButton.disabled = false;
                    reconnectButton.classList.add('hidden');
                };

                ws.onmessage = (event) => {
                    console.log('Received message:', event.data);
                    try {
                        const data = JSON.parse(event.data);
                        switch (data.type) {
                            case 'connected':
                                responseText.textContent = data.message;
                                break;
                            case 'typing':
                                showTypingIndicator();
                                responseText.textContent = data.message;
                                break;
                            case 'chunk':
                                hideTypingIndicator();
                                appendToResponse(data.content);
                                break;
                            case 'complete':
                                hideTypingIndicator();
                                submitButton.disabled = false;
                                submitButton.textContent = 'Send to Orchestrator';
                                isStreaming = false;
                                break;
                            case 'timeout':
                                hideTypingIndicator();
                                responseText.textContent = `⚠️ ${data.message}`;
                                submitButton.disabled = true;
                                isStreaming = false;
                                reconnectButton.classList.remove('hidden');
                                break;
                            case 'error':
                                hideTypingIndicator();
                                responseText.textContent = `Error: ${data.message}`;
                                submitButton.disabled = false;
                                submitButton.textContent = 'Send to Orchestrator';
                                isStreaming = false;
                                break;
                            default:
                                responseText.textContent = typeof data === 'string' ? data : JSON.stringify(data);
                        }
                    } catch (e) {
                        console.error('Error parsing WebSocket message:', e);
                        responseText.textContent = event.data;
                    }
                };

                ws.onclose = () => {
                    console.log('WebSocket connection closed.');
                    responseText.textContent = 'Connection closed.';
                    submitButton.disabled = true;
                    isStreaming = false;
                };

                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    ws.close();
                };
            };

            tryNextWebSocket();
        }

        reconnectButton.addEventListener('click', async () => {
            resetResponse();
            responseText.textContent = 'Starting new session...';
            reconnectButton.classList.add('hidden');
            submitButton.disabled = true;

            if (ws) {
                ws.close();
            }

            try {
                const endpoints = [`${window.location.origin}/messenger/chat/init`, 'http://localhost:40331/messenger/chat/init'];
                let initResponse = null;
                let lastError = null;

                for (const endpoint of endpoints) {
                    try {
                        const response = await fetch(endpoint, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                owner_id: '+12345952496',
                                agent_id: 'AGENT_ID',
                                user_id: 'USER_ID'
                            })
                        });
                        if (response.ok) {
                            initResponse = await response.json();
                            break;
                        }
                    } catch (error) {
                        lastError = error;
                    }
                }

                if (!initResponse || initResponse.status !== 'success') {
                    throw new Error(initResponse?.message || 'Failed to initialize new session');
                }

                sessionInitialized = true;
                sessionId = initResponse.session_id;
                connectWebSocket(sessionId);
            } catch (error) {
                console.error('Reconnect failed:', error);
                responseText.textContent = `Reconnect failed: ${error.message}`;
                reconnectButton.classList.remove('hidden');
            }
        });

        function enableDemoMode() {
            sessionInitialized = true;
            responseText.textContent = 'Demo mode activated. Messages will be echoed back.';
            submitButton.disabled = false;
            form.addEventListener('submit', (event) => {
                event.preventDefault();
                const userMessage = messageInput.value;
                if (!userMessage.trim()) return alert('Please enter a message');
                resetResponse();
                showTypingIndicator();
                submitButton.disabled = true;
                isStreaming = true;
                const demoResponse = `This is a demo response to: "${userMessage}". The LLM would generate this text in real-time.`;
                let currentIndex = 0;
                const streamInterval = setInterval(() => {
                    if (currentIndex < demoResponse.length) {
                        appendToResponse(demoResponse[currentIndex]);
                        currentIndex++;
                    } else {
                        clearInterval(streamInterval);
                        hideTypingIndicator();
                        submitButton.disabled = false;
                        isStreaming = false;
                    }
                }, 50);
                messageInput.value = '';
            });
        }

        const originalFormHandler = (event) => {
            event.preventDefault();
            if (!sessionInitialized || !ws || ws.readyState !== WebSocket.OPEN) {
                responseText.textContent = 'Session not ready. Please wait...';
                return;
            }
            const userMessage = messageInput.value;
            if (!userMessage.trim()) return alert('Please enter a message');
            if (isStreaming) return alert('Please wait for the current response to complete');
            resetResponse();
            showTypingIndicator();
            submitButton.disabled = true;
            submitButton.textContent = 'Sending...';
            isStreaming = true;
            ws.send(userMessage);
            messageInput.value = '';
        };

        form.addEventListener('submit', originalFormHandler);
        initializeSession();
    </script>
</body>
</html>